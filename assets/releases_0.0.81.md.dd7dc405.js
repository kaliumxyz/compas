import{_ as e,c as a,o,a as n}from"./app.d0d65fcc.js";const b='{"title":"Release notes v0.0.81","description":"","frontmatter":{},"headers":[{"level":3,"title":"Chores","slug":"chores"},{"level":3,"title":"Code gen","slug":"code-gen"},{"level":3,"title":"Store","slug":"store"}],"relativePath":"releases/0.0.81.md","lastUpdated":1635769453832}',t={},r=n('<h1 id="release-notes-v0-0-81" tabindex="-1">Release notes v0.0.81 <a class="header-anchor" href="#release-notes-v0-0-81" aria-hidden="true">#</a></h1><p>Compared to v0.0.79 this is a very small release.</p><h3 id="chores" tabindex="-1">Chores <a class="header-anchor" href="#chores" aria-hidden="true">#</a></h3><p>We currently test PR&#39;s against internal projects that use lbu. Currently, it is only a single frontend and backend project, but soon an extra frontend and backend will be added. The builds are failing if either <code>E2E fronted I</code> or <code>E2E backend I</code> are still on a PR.</p><h3 id="code-gen" tabindex="-1">Code gen <a class="header-anchor" href="#code-gen" aria-hidden="true">#</a></h3><p>We also added <code>T.searchable()</code> this allows to have reusable type definitions for things like strings and numbers, but do not want to have it as sql searchable everywhere.</p><h3 id="store" tabindex="-1">Store <a class="header-anchor" href="#store" aria-hidden="true">#</a></h3><p>The biggest part of this release focuses on store. There is now an optional &#39;meta&#39; field on &#39;file&#39;. This is a breaking migration. We also try to resolve migration imports better, by checking nested node_modules and following the <code>main</code> and <code>exports</code> keys from the <code>package.json</code> of a nested namespace.</p><p>Then there is also support for recurring jobs, by providing a name and an interval. Lbu will schedule your jobs on an interval, making sure that only a single job with the provided name is active. It is also possible to provide a priority. The scheduled job will always have a higher priority than the job that is scheduling.</p><p>It boils down to approximately the following:</p><ul><li>Call <code>addRecurringJobToQueue(sql, { name: &quot;foo&quot;, interval: { hours: 1 } })</code> Check if there is an incomplete &#39;scheduling&#39;-job for name &#39;foo&#39;, if not create one.</li><li><code>JobQueueWorker</code> has special handling for the &#39;scheduling&#39;-job, which is handled internally.</li><li>The special handler creates a job scheduled for &#39;now&#39; with name &#39;foo&#39;</li><li>The special handler creates a new &#39;scheduling&#39;-job, taking the interval into account.</li></ul><p>These recurring jobs can be scheduled by using <code>addRecurringJobToQueue</code> only available by importing and not on a <code>JobQueueWorker</code>.</p><h5 id="in-closing" tabindex="-1">In closing <a class="header-anchor" href="#in-closing" aria-hidden="true">#</a></h5><p>We are currently working on a refactor of the code generator. This has mostly breakages in exports, sql relations and various types. I want to give my sincere apologies in advance for all breaking changes in the next release. That&#39;s all for now.</p>',14),i=[r];function s(l,d,c,h,p,u){return o(),a("div",null,i)}var f=e(t,[["render",s]]);export{b as __pageData,f as default};
