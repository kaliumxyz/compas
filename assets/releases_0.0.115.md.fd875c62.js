import{_ as e,c as n,o as s,a}from"./app.d0d65fcc.js";const w='{"title":"Release notes v0.0.115","description":"","frontmatter":{},"headers":[{"level":2,"title":"Code gen","slug":"code-gen"},{"level":2,"title":"Store","slug":"store"},{"level":2,"title":"In closing","slug":"in-closing"}],"relativePath":"releases/0.0.115.md","lastUpdated":1635769453832}',t={},o=a(`<h1 id="release-notes-v0-0-115" tabindex="-1">Release notes v0.0.115 <a class="header-anchor" href="#release-notes-v0-0-115" aria-hidden="true">#</a></h1><p>This release is not that big, but still worth for proper release notes. We go over the changes package by package.</p><h2 id="code-gen" tabindex="-1">Code gen <a class="header-anchor" href="#code-gen" aria-hidden="true">#</a></h2><p>It does not feel like a proper Compas release without some fixes or features added to the code generators, as is the case this time. The table traverser is a relative new feature added in Compas v0.0.103. At that point we did not have a query builder, and generated a stand-alone table traverser that unlocked the following chains:</p><div class="language-js"><pre><code><span class="token comment">// Get all users that liked the specific post</span>
<span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token function">queryUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">viaLikes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">viaPosts</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token operator">:</span> postId <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>This was straight forward to use, but limited in options. You could not use this to filter on two separate &#39; traverse&#39;-chains.</p><p>Next came the query-builder with its built-in support for table traversal. This unlocked traversing via multiple chains, however it was not documented as such. To explain why, let us do a run down of what the traverser does.</p><p>Provided the following structure:</p><div class="language-"><pre><code>User:
- id: uuid
- name: string

Post:
- id: uuid
- writer: uuid -&gt; User
- title: string

Like:
- id: uuid
- user: uuid -&gt; User
- post: uuid -&gt; Post
</code></pre></div><p>We have <code>User</code>, <code>Post</code> and <code>Like</code> as our tables. The relation being that a <code>User</code> is the <code>writer</code> of many <code>Post</code>, and a <code>User</code> can <code>Like</code> many <code>Post</code>. To get all users that have written at least a single post, we can do the following:</p><div class="language-js"><pre><code><span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">queryUser</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  where<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  viaPosts<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Internally, the <code>viaPosts</code> was converted to a <code>QueryPart</code> and thus allowed to be set on the <code>where</code>-object as the <code>idIn</code> field. The <code>QueryPart</code> was a query selecting the <code>writer</code> field from <code>Post</code>.</p><p>If we do one of the following things you would get unexpected results:</p><div class="language-js"><pre><code><span class="token comment">// Get users that have written a post and that are in our selection in &#39;idIn&#39;.</span>
<span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">queryUser</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  where<span class="token operator">:</span> <span class="token punctuation">{</span>
    idIn<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;uuid-110&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;uuid-120&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;uuid-130&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  viaPosts<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Get users that have written a post and have liked an post</span>
<span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">queryUser</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  where<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  viaPosts<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  viaLikes<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>We have a problem in both cases. In our first case we already set <code>idIn</code> however <code>viaPosts</code> will overwrite it. In the second case, since both <code>Like</code> and <code>Post</code> are referenced via the <code>id</code> on a <code>User</code>, <code>viaLikes</code> would overwrite <code>viaPosts</code> since they both set directly the <code>idIn</code> property on the provided <code>where</code> object.</p><p>Of course not all references would go via the <code>idIn</code> parameter, so indirectly the generated traverser could work with multiple chains, but would fail on the most useful cases.</p><p>In this release we solve these cases. We now generate an <code>INTERSECT</code> query from all <code>viaXxx</code> calls and if necessary combine it with an existing <code>idIn</code> array. <code>INTERSECT</code> gives us the same <code>AND</code> guarantees as normal <code>where</code> filters.</p><h2 id="store" tabindex="-1">Store <a class="header-anchor" href="#store" aria-hidden="true">#</a></h2><p>The <code>JobQueueWorker</code> got two upgrades as well, breaking existing behaviour.</p><p><strong>Managed retries</strong>:</p><p>The worker now won&#39;t leak any errors that are thrown by job handler invocations. Instead, all errors are caught. On error the job id, name, retryCount and error are logged via an error log. The <code>retryCount</code> is then increased and sql transaction is committed.</p><p>By adding a savepoint, we can rollback any queries done by the job handler. Note that you won&#39;t see failed transactions from the worker anymore, so that metric may become less relevant for you. We added a <code>maxRetryCount</code> to the options that can be provided to the constructor, it defaults to <code>5</code>.</p><p><strong>Handler timeouts</strong></p><p>To prevent that the worker is too busy with a job, comes in a infinite async loop or for some other reason takes long to complete. We now automatically stop the job and let it be processed as if an error was thrown by the handler. Which results in an increased <code>retryCount</code>. Note that this won&#39;t work correctly if the job does only synchronous processing.</p><p>The timeout can be configured via the constructor options under <code>handlerTimeout</code> in milliseconds, and defaults to 30 seconds.</p><h2 id="in-closing" tabindex="-1">In closing <a class="header-anchor" href="#in-closing" aria-hidden="true">#</a></h2><p>Some other chores are being done as well, like writing docs (A). The Compas repo will now require use of conventional-commit like specifiers in the commit title, like <code>feat</code>, <code>fix</code>, etc. This was decided after some feedback to get a quicker overview of the current state of development.</p><p>I am also experimenting a bit with JSDoc based documentation again. We had TSDoc based documentation for a while, based on the <code>index.d.ts</code> files that we provide. The output was too unstructured, and overall hard to use in any form. If anyone has any suggestions please let me know directly or via the <a href="https://github.com/compasjs/compas/issues/568" target="_blank" rel="noopener noreferrer">Align JSDoc issue</a>.</p>`,28),c=[o];function p(r,i,d,l,u,h){return s(),n("div",null,c)}var g=e(t,[["render",p]]);export{w as __pageData,g as default};
